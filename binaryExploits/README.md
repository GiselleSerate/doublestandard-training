Source code from https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/

Modifications made for a 64-bit system, because that's probably what you have. 

*******

## Background
Here's a decently detailed Computerphile video about buffer overflow attacks. Our exploit is a good bit simpler than the one he's doing in this video--the only thing that we care about is overwriting the return address so that it points to a different function in the program. The video goes over nop sleds and how to inject your own code, which is beyond the scope of this exercise in particular, but if you'd like to take this exercise further and figure out how to run an exploit of that sort, you're definitely welcome to. https://www.youtube.com/watch?v=1S0aBV-Waeo

*******

## Running the exploit

Run `sudo sysctl kernel.randomize_va_space=0` in your terminal, which will temporarily turn stack randomization off for just this session. 

Open the `vuln.c` file. What does it do? How would you get to the secret function? 

Run the command `gcc vuln.c -o vuln -fno-stack-protector -g`. This compiles the `vuln.c` program into an executable `vuln` program. `-fno-stack-protector` turns off all the things that a good compiler should do to prevent you from doing this exploit. `-g` allows you to open the executable in a debugger. (Since a Makefile is provided, you can also just run `make` since that's shorter to type, but this is the command that's actually getting run.) 

(If you want to run the Computerphile attack where you actually execute code you're injecting onto the stack, you'll need to add `-z execstack` to your gcc command, which means that you're allowed to execute code on the stack. This flag isn't necessary for the basic attack, since you're only changing the return address.)

Try out the program. Run `./vuln` and give it some text so you can see how the program's expected to work. 

Run `objdump -d vuln > myVulnDump`, which allows you to look through the machine instructions for the executable. Note that you can get this objdump without the original C source file. You can now open myVulnDump with `nano` or some other text editor. 
<br>
<details>
  <summary>It's not working!</summary>
  If you really can't get the objdump to work, I've provided it as `dumpfile`.
</details>
<br>
In the dumpfile, locate the address in main where the echo function should return to when it's finished. This is the address that will get pushed to the stack, and then the program will expect it to be there later. Except we're going to overwrite it to a different address. 
<br>
<details> 
  <summary>The return address should be... </summary>
  0x400640
</details>
<br>
Also in the dumpfile, locate the address of the secret function. This is what we'll be overwriting the last address with. 
<br>
<details> 
  <summary>The address of secretFunction should be... </summary>
  0x4005d6
</details>
<br>
Construct a hex string that will overflow the buffer with a set number of random characters followed by the return address of the secret function. I used Python: `python -c 'print "a"*40 + "\xd6\x05\x40"' > myBadString`. (If you discovered that yours has a different return address, use that one instead.) If you're curious, you can use hexdump to figure out what got put into the myBadString file: `hexdump myBadString`
<br>
<details>
  <summary>It's not working!</summary>
  Because of how different machines' endianness works, the bytes of the string are reversed for mine; if this doesn't work, try substituting `\x40\x05\xd6`.
</details>
<br>
Now run the `vuln` program with the string you put into `myBadString`: `./vuln < myBadString`. 

And that's it! 

![I'm in.](in.gif)
https://media.giphy.com/media/xUOxf0mVWDzAX9HkOY/giphy.gif
