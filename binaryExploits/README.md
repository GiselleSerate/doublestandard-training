Source code from https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/

Modifications made for a 64-bit system, because that's probably what you have. 

*******

## Running the exploit

Run `sudo sysctl kernel.randomize_va_space=0` in your terminal, which will temporarily turn stack randomization off for just this session. 

Open the `vuln.c` file. What does it do? How would you get to the secret function? 

Run the command `gcc vuln.c -o vuln -fno-stack-protector -g`. This compiles the `vuln.c` program into an executable `vuln` program. `-fno-stack-protector` turns off all the things that a good compiler should do to prevent you from doing this exploit. `-g` allows you to open the executable in a debugger. (Since a Makefile is provided, you can also just run `make` since that's shorter to type, but this is the command that's actually getting run.) 

Try out the program. Run `./vuln` and give it some text so you can see how the program's expected to work. 

Run `objdump -d vuln > myVulnDump`, which allows you to look through the machine instructions for the executable. Note that you can get this objdump without the original C source file. You can now open myVulnDump with `nano` or some other text editor. 
<br>
<details>
  <summary>It's not working!</summary>
  If you really can't get the objdump to work, I've provided it as `dumpfile`.
</details>
<br>
In the dumpfile, locate the address in main where the echo function should return to when it's finished. This is the address that will get pushed to the stack, and then the program will expect it to be there later. Except we're going to overwrite it to a different address. 
<br>
<details> 
  <summary>The return address should be... </summary>
  0x400640
</details>
<br>
Also in the dumpfile, locate the address of the secret function. This is what we'll be overwriting the last address with. 
<br>
<details> 
  <summary>The address of secretFunction should be... </summary>
  0x4005d6
</details>
<br>
Construct a hex string that will overflow the buffer with a set number of random characters followed by the return address of the secret function. I used Python: `python -c 'print "a"*40 + "\xd6\x05\x40"' > myBadString`. (If you discovered that yours has a different return address, use that one instead.) If you're curious, you can use hexdump to figure out what got put into the myBadString file: `hexdump myBadString`
<br>
<details>
  <summary>It's not working!</summary>
  Because of how different machines' endianness works, the bytes of the string are reversed for mine; if this doesn't work, try substituting `\x40\x05\xd6`.
</details>
<br>
Now run the `vuln` program with the string you put into `myBadString`: `./vuln < myBadString`. 

And that's it! 

![I'm in.](in.gif)
https://media.giphy.com/media/xUOxf0mVWDzAX9HkOY/giphy.gif
